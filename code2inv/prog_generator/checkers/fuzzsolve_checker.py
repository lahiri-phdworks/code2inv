# Run fuzz solver as subprocess and
# then use it to test the invariants.

# AFL/fuzzsolver module.
import sys
import time
import tokenize
import io
import os
from tqdm import tqdm
from code2inv.prog_generator.chc_tools.chctools.horndb import *
from code2inv.prog_generator.chc_tools.chctools.solver_utils import *
from subprocess import run, CalledProcessError

set_build = False
pwd = os.path.dirname(__file__)
example = os.environ['INVPROCESSFILE']
timeout = 15

dump_results = os.path.join(pwd, os.pardir, f"results/log_inv_{example}.txt")
filepath = os.path.join(pwd, os.pardir, f"fuzz/include/{example}.h")
fuzzbase = os.path.join(pwd, os.pardir, f"fuzz")


def get_c_code(inv: str):
    # TODO : Convert inv to c-code.
    tqdm.write(f"Invariant -> {repr(inv)}")


def inv_checker(model, eval_string_inv: str):
    # COMMENT : Check if the given inv condition is satisfied
    # else return model
    pass


def call_fuzzsolver():
    # TODO : Get counter example model out of afl "crash" case.
    # TODO : Try out for "ssum" case and then extract model for counter examples here.
    try:
        print(f"Running AFL on Example {example}.c")
        output = run(
            f'timeout {timeout} {fuzzbase}/fuzz.sh -b {fuzzbase}/build -t {fuzzbase}/tests -m 10G -o {fuzzbase}/output -e {example}',
            shell=True, text=True)
    except CalledProcessError as err:
        print(f"Fuzzer Error : {err}")
    else:
        print(f"Fuzzer Return : {output.returncode}")
    return output.returncode


def init_fuzzbase():
    try:
        print(f"Initialized AFL run on Example {example}.c")
        output = run(
            f'{fuzzbase}/start.sh -b {fuzzbase}/build -t {fuzzbase}/tests -o {fuzzbase}/output -e {example}',
            shell=True, text=True)
    except CalledProcessError as err:
        print(f"Build Error : {err}")
    else:
        print(f"Build Return : {output.returncode}")


def dump_template(file: str, inv_code: str):
    with open(file, mode="w") as fileptr:
        fileptr.write(f"#define PHI ({inv_code}) // generated by code2inv\n")


def process_crashes():
    # COMMENT : iterate over all crashes inputs and extract test failures
    pass


def inv_solver(vc_file: str, inv: str):
    # COMMENT : Gets called in each env.step() iteration.
    # COMMENT : None of these functions must fail here.
    tqdm.write("fuzz-inv solver called")

    get_c_code(str)
    init_fuzzbase()
    res = call_fuzzsolver()
    vcexspath = os.path.join(os.path.dirname(
        __file__), os.pardir, "results", f"log_cexs_{os.environ['INVPROCESSFILE']}.txt")
    with open(vcexspath, mode="a") as file:
        file.write(f"\nProposed Invariant : (inv) -> {inv}")
        file.write(
            f"\nCounter Example : (pre, inv, post) -> {[None, None, None]}")
    return [res, res, res]


if __name__ == '__main__':
    print("Fuzz Solver Raw")
    inv_solver(
        "", "( and ( >= y ( + 36 1 ) ) ( or ( = c ( * 1 y ) ) ( >= z 127 ) ) )")
