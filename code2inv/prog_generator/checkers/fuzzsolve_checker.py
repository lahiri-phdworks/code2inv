# Run fuzz solver as subprocess and
# then use it to test the invariants.

# AFL/fuzzsolver module.
import subprocess
import os

pwd = os.path.dirname(__file__)
example = os.environ['INVPROCESSFILE']

filepath = os.path.join(pwd, os.pardir, f"fuzz/include/{example}.h")
dump_results = os.path.join(pwd, os.pardir, f"results/log_inv_{example}.txt")
fuzzbase = os.path.join(pwd, os.pardir, f"fuzz")


def get_c_code(inv: str):
    # Parse SMT and convert to C code.

    # COMMENT : Just using existing proposed INV to check.
    with open(dump_results, mode="r") as fileptr:
        inv_c_code = fileptr.readline().strip().split(":")[1]

    return inv_c_code


def inv_checker(model, eval_string_inv):
    # COMMENT : Check if the given inv condition is satisfied
    # else return model
    pass


def call_fuzzsolver():
    try:
        # Refactor to use Popen() for bidrectional i/o.
        output = subprocess.check_output(
            f'{fuzzbase}/start.sh -b {fuzzbase}/build -t {fuzzbase}/tests -o {fuzzbase}/output -e {example}', shell=True)
        print(f"Running AFL on Example {example}.c")
    except subprocess.CalledProcessError as err:
        print(f"Error : {err}")
    else:
        print(output)


def dump_template(file: str, inv_code: str):
    with open(file, mode="w") as fileptr:
        fileptr.write(f"#define PHI ({inv_code}) // generated by code2inv\n")


def extract_crashes():
    crashes = f'{fuzzbase}/output/master_fuzz_{example}/crashes'
    # COMMENT : iterate over all crashes inputs and extract test failures
    pass


def inv_solver(vc_file: str, inv: str):
    inv_code = get_c_code(str)
    dump_template(filepath, inv_code)

    call_fuzzsolver()
    extract_crashes()
    return [None, None, None]


if __name__ == '__main__':
    print("Fuzz Solver Raw")
    inv_solver(
        "", "( and ( >= y ( + 36 1 ) ) ( or ( = c ( * 1 y ) ) ( >= z 127 ) ) )")
